# Resolving Mockito and JVM Agent Warning

## Test Execution Warnings

When running Java tests using recent versions of the JDK and the Mockito framework, you may encounter several warnings.
Although these warnings seem different, they all stem from the same underlying problem. They usually appear as a block
of text that looks something like this (often highlighted in red for emphasis)::

```
Mockito is currently self-attaching to enable the inline-mock-maker. This will no longer work in future releases of the JDK. Please add Mockito as an agent to your build as described in Mockito's documentation: https://javadoc.io/doc/org.mockito/mockito-core/latest/org.mockito/org/mockito/Mockito.html#0.3
OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
WARNING: A Java agent has been loaded dynamically (/home/dio/.m2/repository/net/bytebuddy/byte-buddy-agent/1.17.7/byte-buddy-agent-1.17.7.jar)
WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
WARNING: Dynamic loading of agents will be disallowed by default in a future release
```

These warnings are not indicative of an error in the test logic itself but rather signal a misalignment between the
testing framework's operational mechanism and the evolving rules of the JVM.

The first message, `Mockito is currently self-attaching...`, originates directly from the Mockito framework. It
serves as a proactive notification, informing us that it is using a legacy mechanism to enable its advanced
features and explicitly recommends change the configuration.

The next block of warnings, beginning with `WARNING: A Java agent has been loaded dynamically...`, is generated by
the JVM. The JVM has detected that Mockito, through its underlying bytecode manipulation library ByteBuddy, has
dynamically attached a Java Agent to the running process. The warnings tell us that this practice is now discouraged
and will be disallowed by default in a future release due to security considerations.

The line, `OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes...`, is a secondary
side effect. It relates to a JVM performance optimization known as Class Data Sharing (CDS), which is partially disabled
when a Java agent modifies the bootstrap classpath, as Mockito's agent does.

## JVM and Dynamic Agents

A Java Agent is a special type of program that can instrument (modify the bytecode) Java classes as they are
loaded by the JVM. This powerful capability is enabled by the Java Instrumentation API and is the basis for many
profiling, monitoring, and testing tools.

There are two primary ways to attach an agent to a JVM process:

1. **Static Attachment:** The agent is specified at JVM startup using the `-javaagent:<path-to-agent.jar>` command-line
   flag. This is an explicit, pre-approved instrumentation of the process.
2. **Dynamic Attachment:** The agent attaches to an already running JVM process. This mechanism offers flexibility but
   also presents a potential security vector.

In the past, tools like Mockito used dynamic attachment to make things easier. It allowed the framework to enable
advanced features on-demand, without requiring developers to pre-configure their build environments. However, with the
increasing focus on runtime integrity and security, the OpenJDK team has moved to restrict dynamic agent loading.
Starting with warnings in JDK 17 and with plans to disallow it by default, so the JVM now discourages this practice. The
rationale is to prevent malicious code from secretly attaching to a running application and altering its behavior
in unforeseen ways. By requiring agents to be declared statically at startup, the environment's configuration becomes
explicit and auditable, enhancing overall system security.

## Mockito's Inline Mock Maker

Mockito is one of the most popular mocking frameworks in the Java ecosystem. Its core functionality allows developers
to create mock objects of interfaces and non-final classes. However, real-world projects often involve legacy code or
third-party libraries that make extensive use of `final` classes, `final` methods, or `static` methods. Testing code
that interacts with these constructs was historically very difficult, often requiring cumbersome workarounds or more
invasive tools like PowerMock.

To address this, Mockito introduced the **inline mock maker**. This powerful extension enables Mockito to mock
constructs that are normally un-mockable, including:

* `final` classes and methods
* `static` methods
* Object constructors

The inline mock maker does this by using a Java Agent to change the code of classes while they are running. It uses the
ByteBuddy library, which can connect to the JVM and change the class code as needed. For example, to mock a `final`
class, the agent can effectively remove the `final` modifier from the class definition before it is used, allowing
Mockito to then create a subclass-based mock as it normally would.

When a test requires the mocking of a `final` class or a `static` method, Mockito's inline mock maker is activated. This
activation involves dynamically attaching the ByteBuddy agent to the running JVM.
This is precisely the behavior that modern JDKs have begun to warn against with the
`WARNING: A Java agent has been loaded dynamically` message.

## `mockito-inline` and `mockito-core`

For many years, the standard Mockito artifact was `mockito-core`. To use the advanced features of the inline mock maker,
we had to explicitly add a separate dependency, `mockito-inline`, to the project's build configuration. This created a
clear separation: `mockito-core` for standard mocking and `mockito-inline` for advanced cases.

This changed with the release of **Mockito 5**. In this major update, the inline mock maker was made the default mock
maker for the entire framework. Its functionality was merged directly into the `mockito-core` artifact. As a result, the
separate `mockito-inline` dependency became obsolete and is no longer published or required.

When we upgraded the projects to `mockito-core` 5, or later we have the inline mock maker's capabilities, whether we
were aware of it or not.
As a result, any test that used a mock for a `final` class (a common occurrence in projects using frameworks like
Spring) would now silently trigger the dynamic agent attachment mechanism. When this upgrade coincided with a move to a
modern JDK, the hidden configuration problem would show up as a series of JVM warnings.

## The Solution

The solution is to configure the build system to launch the test JVM with the Mockito agent attached statically. This
satisfies both Mockito's need for an agent to power the inline mock maker and the JVM's requirement for explicit,
startup-time agent declaration.

### Configuring Maven Projects (Surefire & Failsafe)

In Maven projects, test execution is handled by the `maven-surefire-plugin` for unit tests (bound to the `test` phase)
and the `maven-failsafe-plugin` for integration tests (bound to the `integration-test` and `verify` phases). The
configuration must be applied to whichever of these plugins is in use, or both for comprehensive coverage.

The configuration involves adding a JVM argument to the test process via the `<argLine>` element. The path to the
Mockito agent JAR must be constructed dynamically to avoid hardcoding version numbers or local repository paths. Maven
properties provide a robust way to achieve this.

A common pitfall, however, is that other Maven plugins, most notably JaCoCo for code coverage, also use the `<argLine>`
property. A naive configuration can lead to one agent's configuration overwriting another's. The solution is to use the
`@{argLine}` syntax, a feature of the Surefire plugin (version 2.17+), which instructs Maven to append the new argument
to any value that may have already been set for the `argLine` property by other plugins.

Below is the configuration for the `maven-surefire-plugin` with `jacoco-maven-plugin`. An identical
`<configuration>` block should be added to the `maven-failsafe-plugin` if it is also used in the project.

```xml

<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>${jacoco-maven-plugin.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>verify</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-surefire-plugin</artifactId>
<configuration>
    <argLine>
        @{argLine}
        -javaagent:${settings.localRepository}/org/mockito/mockito-core/${mockito.version}/mockito-core-${mockito.version}.jar
        -Xshare:off
    </argLine>
</configuration>
</plugin>
```

If you are not using `jacoco-maven-plugin` the config is as follows:

```xml

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <argLine>
            -javaagent:${settings.localRepository}/org/mockito/mockito-core/${mockito.version}/mockito-core-${mockito.version}.jar
            -Xshare:off
        </argLine>
    </configuration>
</plugin>
```

## Class Data Sharing and Agent Interaction

The final warning message,
`OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended`,
is often the most confusing because it relates to a low-level JVM performance optimization that most developers do not
directly interact with. Fortunately, in the context of running tests, it is almost always irrelevant.

### Class Data Sharing (CDS) / AppCDS

Class Data Sharing (CDS) and its extension, Application Class-Data Sharing (AppCDS), are features of the HotSpot JVM
designed to reduce application startup time and memory footprint. During a training run of an application, the
JVM can create a shared archive file containing information about the classes that were loaded, including their
bytecode, metadata, and internal data structures. On subsequent launches, the JVM can map this archive directly into
memory, allowing it to load classes much faster than by parsing them from JAR files. By default, modern JDKs ship with a
pre-built CDS archive for the core JDK classes.

### Why Java Agents Can Disrupt CDS

The key to understanding the warning is the phrase `...because bootstrap classpath has been appended`. The
bootstrap classpath is the list of locations where the JVM finds its most fundamental classes (like `java.lang.Object`).
The integrity of the pre-built CDS archive depends on this classpath remaining unchanged.

However, some Java Agents, including the one used by Mockito's inline mock maker, need to instrument classes that are
loaded by the bootstrap class loader. To do this, they add their own agent JAR to the bootstrap classpath at
startup. The JVM detects this modification and recognizes that the environment no longer perfectly matches the
one in which the CDS archive was created. As a safety measure, it partially deactivates class data sharing for classes
loaded by the system and application class loaders, as their integrity can no longer be guaranteed by the archive. It
then prints the warning to inform the user that this performance optimization has been partially disabled. This same
warning is commonly seen when using other agents, such as those for application performance monitoring (APM).

### Ignore or Silence the Warnings

Given that the warning indicates a partial deactivation of a startup performance optimization, its impact on the
execution of a test suite is typically negligible. The milliseconds saved during JVM startup are insignificant compared
to the overall time spent running the tests themselves.

Therefore, the most practical thing to do is to **safely ignore this warning**. It is an informational message from the
JVM, not an error, and it does not affect the correctness or behavior of the tests.

However, for teams that enforce a zero-warning policy or find the message distracting in their logs, there are two ways
to silence it:

1. **Disable Class Data Sharing:** The most direct way to eliminate the warning is to completely turn off the feature
   that causes it. This can be done by adding the `-Xshare:off` flag to the JVM arguments. In Maven's `pom.xml`, this
   would be added to the `<argLine>`. This will silence the warning at the cost of a potentially marginal increase in
   test JVM startup time.

2. **Suppress All JVM Warnings:** A more heavy-handed approach is to use the non-standard flag `-XX:-PrintWarnings`.
   This will suppress *all* warnings from the JVM, not just the CDS warning. This option should be used with extreme
   caution, as it may hide other important diagnostic information from the JVM.